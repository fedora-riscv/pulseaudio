From 70721d64d1bd4428d59cb4038eb56d9d79cf24fc Mon Sep 17 00:00:00 2001
From: Wim Taymans <wtaymans@redhat.com>
Date: Fri, 27 Jan 2017 16:41:41 +0100
Subject: [PATCH 11/18] Add access checks

Put some access control checks in various core objects
---
 src/pulsecore/card.c              |   6 ++
 src/pulsecore/client.c            |   3 +
 src/pulsecore/core-scache.c       |  12 +++
 src/pulsecore/core-subscribe.c    |   6 +-
 src/pulsecore/core.c              | 176 ++++++++++++++++++++++++++++++++++----
 src/pulsecore/core.h              |   4 +
 src/pulsecore/module.c            |  18 ++++
 src/pulsecore/namereg.c           |  27 +++++-
 src/pulsecore/protocol-native.c   |   1 +
 src/pulsecore/sink-input.c        |  27 ++++++
 src/pulsecore/sink.c              |  22 +++++
 src/pulsecore/sound-file-stream.c |   3 +
 src/pulsecore/source-output.c     |  21 +++++
 src/pulsecore/source.c            |  21 +++++
 14 files changed, 325 insertions(+), 22 deletions(-)

diff --git a/src/pulsecore/card.c b/src/pulsecore/card.c
index 39f4261..5018d07 100644
--- a/src/pulsecore/card.c
+++ b/src/pulsecore/card.c
@@ -296,6 +296,9 @@ int pa_card_set_profile(pa_card *c, pa_card_profile *profile, bool save) {
     pa_assert(profile);
     pa_assert(profile->card == c);
 
+    if (!pa_core_check_access_sync(c->core, PA_ACCESS_HOOK_SET_CARD_PROFILE, c->index, 0, NULL))
+        return -PA_ERR_ACCESS;
+
     if (!c->set_profile) {
         pa_log_debug("set_profile() operation not implemented for card %u \"%s\"", c->index, c->name);
         return -PA_ERR_NOTIMPLEMENTED;
@@ -378,6 +381,9 @@ int pa_card_suspend(pa_card *c, bool suspend, pa_suspend_cause_t cause) {
     pa_assert(c);
     pa_assert(cause != 0);
 
+    if (!pa_core_check_access_sync(c->core, PA_ACCESS_HOOK_SUSPEND_CARD, c->index, 0, NULL))
+        return -1;
+
     suspend_cause = c->suspend_cause;
 
     if (suspend)
diff --git a/src/pulsecore/client.c b/src/pulsecore/client.c
index 24faa1f..fa10ae1 100644
--- a/src/pulsecore/client.c
+++ b/src/pulsecore/client.c
@@ -112,6 +112,9 @@ void pa_client_free(pa_client *c) {
 void pa_client_kill(pa_client *c) {
     pa_assert(c);
 
+    if (!pa_core_check_access_sync(c->core, PA_ACCESS_HOOK_KILL_CLIENT, c->index, 0, NULL))
+        return;
+
     if (!c->kill) {
         pa_log_warn("kill() operation not implemented for client %u", c->index);
         return;
diff --git a/src/pulsecore/core-scache.c b/src/pulsecore/core-scache.c
index 8d54720..4eaa997 100644
--- a/src/pulsecore/core-scache.c
+++ b/src/pulsecore/core-scache.c
@@ -97,6 +97,9 @@ static pa_scache_entry* scache_add_item(pa_core *c, const char *name, bool *new_
     pa_assert(name);
     pa_assert(new_sample);
 
+    if (!pa_core_check_access_sync(c, PA_ACCESS_HOOK_ADD_SAMPLE, PA_INVALID_INDEX, 0, name))
+       return NULL;
+
     if ((e = pa_namereg_get(c, name, PA_NAMEREG_SAMPLE))) {
         if (e->memchunk.memblock)
             pa_memblock_unref(e->memchunk.memblock);
@@ -281,6 +284,9 @@ int pa_scache_remove_item(pa_core *c, const char *name) {
     if (!(e = pa_namereg_get(c, name, PA_NAMEREG_SAMPLE)))
         return -1;
 
+    if (!pa_core_check_access_sync(c, PA_ACCESS_HOOK_REMOVE_SAMPLE, PA_INVALID_INDEX, 0, name))
+       return -1;
+
     pa_assert_se(pa_idxset_remove_by_data(c->scache, e, NULL) == e);
 
     pa_log_debug("Removed sample \"%s\"", name);
@@ -293,6 +299,9 @@ int pa_scache_remove_item(pa_core *c, const char *name) {
 void pa_scache_free_all(pa_core *c) {
     pa_assert(c);
 
+    if (!pa_core_check_access_sync(c, PA_ACCESS_HOOK_REMOVE_SAMPLE, PA_INVALID_INDEX, 0, NULL))
+       return;
+
     pa_idxset_remove_all(c->scache, (pa_free_cb_t) free_entry);
 
     if (c->scache_auto_unload_event) {
@@ -314,6 +323,9 @@ int pa_scache_play_item(pa_core *c, const char *name, pa_sink *sink, pa_volume_t
     if (!(e = pa_namereg_get(c, name, PA_NAMEREG_SAMPLE)))
         return -1;
 
+    if (!pa_core_check_access_sync(c, PA_ACCESS_HOOK_PLAY_SAMPLE, e->index, 0, NULL))
+       return -1;
+
     merged = pa_proplist_new();
     pa_proplist_sets(merged, PA_PROP_MEDIA_NAME, name);
     pa_proplist_sets(merged, PA_PROP_EVENT_ID, name);
diff --git a/src/pulsecore/core-subscribe.c b/src/pulsecore/core-subscribe.c
index 88d900b..e60af21 100644
--- a/src/pulsecore/core-subscribe.c
+++ b/src/pulsecore/core-subscribe.c
@@ -169,8 +169,10 @@ static void defer_cb(pa_mainloop_api *m, pa_defer_event *de, void *userdata) {
 
         for (s = c->subscriptions; s; s = s->next) {
 
-            if (!s->dead && pa_subscription_match_flags(s->mask, e->type))
-                s->callback(c, e->type, e->index, s->userdata);
+            if (!s->dead && pa_subscription_match_flags(s->mask, e->type)) {
+                if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_FILTER_SUBSCRIBE_EVENT, e->index, e->type, NULL))
+                  s->callback(c, e->type, e->index, s->userdata);
+            }
         }
 
 #ifdef DEBUG
diff --git a/src/pulsecore/core.c b/src/pulsecore/core.c
index b068f5d..6b9fb8b 100644
--- a/src/pulsecore/core.c
+++ b/src/pulsecore/core.c
@@ -257,6 +257,8 @@ int pa_core_exit(pa_core *c, bool force, int retval) {
 
     if (c->disallow_exit && !force)
         return -1;
+    if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_EXIT_DAEMON, PA_INVALID_INDEX, 0, NULL))
+        return -1;
 
     c->mainloop->quit(c->mainloop, retval);
     return 0;
@@ -330,70 +332,212 @@ pa_mempool* pa_core_new_mempool(pa_core *c, pa_mem_type_t shm_type, bool per_cli
     return pa_mempool_new(shm_type, c->shm_size, per_client);
 }
 
+bool pa_core_check_access_sync(pa_core *c, pa_access_hook_t hook, uint32_t idx, pa_subscription_event_type_t event, const char *name) {
+    pa_access_data data;
+
+    pa_assert(c);
+
+    if (c->current_client == NULL)
+      return true;
+
+    data.hook = hook;
+    data.client_index = c->current_client->index;
+    data.object_index = idx;
+    data.event = event;
+    data.name = name;
+    data.complete_cb = NULL;
+
+    return pa_hook_fire(&c->access[data.hook], &data) == PA_HOOK_OK;
+}
+
+pa_hook_result_t pa_core_check_access(pa_core *c, pa_access_data *data) {
+    pa_assert(c);
+    pa_assert(data);
+
+    if (c->current_client == NULL)
+      return PA_HOOK_OK;
+
+    data->client_index = c->current_client->index;
+
+    return pa_hook_fire(&c->access[data->hook], data);
+}
+
 /* FIXME: Should these be taking a ref during the copy? */
 
 pa_idxset* pa_core_get_modules(pa_core *c) {
-    return pa_idxset_copy(c->modules, NULL);
+    pa_idxset *s;
+    uint32_t idx;
+    pa_module *e;
+
+    s = pa_idxset_new(NULL, NULL);
+    PA_IDXSET_FOREACH(e, c->modules, idx) {
+        if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_MODULE, e->index, 0, NULL))
+            pa_idxset_put(s, e, NULL);
+    }
+    return s;
 }
 
 pa_idxset* pa_core_get_clients(pa_core *c) {
-    return pa_idxset_copy(c->clients, NULL);
+    pa_idxset *s;
+    uint32_t idx;
+    pa_client *e;
+
+    s = pa_idxset_new(NULL, NULL);
+    PA_IDXSET_FOREACH(e, c->clients, idx) {
+        if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_CLIENT, e->index, 0, NULL))
+            pa_idxset_put(s, e, NULL);
+    }
+    return s;
 }
 
 pa_idxset* pa_core_get_cards(pa_core *c) {
-    return pa_idxset_copy(c->cards, NULL);
+    pa_idxset *s;
+    uint32_t idx;
+    pa_card *e;
+
+    s = pa_idxset_new(NULL, NULL);
+    PA_IDXSET_FOREACH(e, c->cards, idx) {
+        if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_CARD, e->index, 0, NULL))
+            pa_idxset_put(s, e, NULL);
+    }
+    return s;
 }
 
 pa_idxset* pa_core_get_sinks(pa_core *c) {
-    return pa_idxset_copy(c->sinks, NULL);
+    pa_idxset *s;
+    uint32_t idx;
+    pa_sink *e;
+
+    s = pa_idxset_new(NULL, NULL);
+    PA_IDXSET_FOREACH(e, c->sinks, idx) {
+        if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SINK, e->index, 0, NULL))
+            pa_idxset_put(s, e, NULL);
+    }
+    return s;
 }
 
 pa_idxset* pa_core_get_sources(pa_core *c) {
-    return pa_idxset_copy(c->sources, NULL);
+    pa_idxset *s;
+    uint32_t idx;
+    pa_source *e;
+
+    s = pa_idxset_new(NULL, NULL);
+    PA_IDXSET_FOREACH(e, c->sources, idx) {
+        if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SOURCE, e->index, 0, NULL))
+            pa_idxset_put(s, e, NULL);
+    }
+    return s;
 }
 
 pa_idxset* pa_core_get_sink_inputs(pa_core *c) {
-    return pa_idxset_copy(c->sink_inputs, NULL);
+    pa_idxset *s;
+    uint32_t idx;
+    pa_sink_input *e;
+
+    s = pa_idxset_new(NULL, NULL);
+    PA_IDXSET_FOREACH(e, c->sink_inputs, idx) {
+        if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SINK_INPUT, e->index, 0, NULL))
+            pa_idxset_put(s, e, NULL);
+    }
+    return s;
 }
 
 pa_idxset* pa_core_get_source_outputs(pa_core *c) {
-    return pa_idxset_copy(c->source_outputs, NULL);
+    pa_idxset *s;
+    uint32_t idx;
+    pa_source_output *e;
+
+    s = pa_idxset_new(NULL, NULL);
+    PA_IDXSET_FOREACH(e, c->source_outputs, idx) {
+        if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SOURCE_OUTPUT, e->index, 0, NULL))
+            pa_idxset_put(s, e, NULL);
+    }
+    return s;
 }
 
 pa_idxset* pa_core_get_scache(pa_core *c) {
-    return pa_idxset_copy(c->scache, NULL);
+    pa_idxset *s;
+    uint32_t idx;
+    pa_scache_entry *e;
+
+    s = pa_idxset_new(NULL, NULL);
+    PA_IDXSET_FOREACH(e, c->scache, idx) {
+        if (pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SAMPLE, e->index, 0, NULL))
+            pa_idxset_put(s, e, NULL);
+    }
+    return s;
 }
 
 pa_module* pa_core_get_module(pa_core *c, uint32_t idx) {
-    return pa_idxset_get_by_index(c->modules, idx);
+    pa_module *e = pa_idxset_get_by_index(c->modules, idx);
+
+    if (e == NULL || !pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_MODULE, e->index, 0, NULL))
+      return NULL;
+
+    return e;
 }
 
 pa_client* pa_core_get_client(pa_core *c, uint32_t idx) {
-    return pa_idxset_get_by_index(c->clients, idx);
+    pa_client *e = pa_idxset_get_by_index(c->clients, idx);
+
+    if (e == NULL || !pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_CLIENT, e->index, 0, NULL))
+      return NULL;
+
+    return e;
 }
 
 pa_card* pa_core_get_card(pa_core *c, uint32_t idx) {
-    return pa_idxset_get_by_index(c->cards, idx);
+    pa_card *e = pa_idxset_get_by_index(c->cards, idx);
+
+    if (e == NULL || !pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_CARD, e->index, 0, NULL))
+      return NULL;
+
+    return e;
 }
 
 pa_sink* pa_core_get_sink(pa_core *c, uint32_t idx) {
-    return pa_idxset_get_by_index(c->sinks, idx);
+    pa_sink *e = pa_idxset_get_by_index(c->sinks, idx);
+
+    if (e == NULL || !pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SINK, e->index, 0, NULL))
+      return NULL;
+
+    return e;
 }
 
 pa_source* pa_core_get_source(pa_core *c, uint32_t idx) {
-    return pa_idxset_get_by_index(c->sources, idx);
+    pa_source *e = pa_idxset_get_by_index(c->sources, idx);
+
+    if (e == NULL || !pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SOURCE, e->index, 0, NULL))
+      return NULL;
+
+    return e;
 }
 
 pa_sink_input* pa_core_get_sink_input(pa_core *c, uint32_t idx) {
-    return pa_idxset_get_by_index(c->sink_inputs, idx);
+    pa_sink_input *e = pa_idxset_get_by_index(c->sink_inputs, idx);
+
+    if (e == NULL || !pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SINK_INPUT, e->index, 0, NULL))
+      return NULL;
+
+    return e;
 }
 
 pa_source_output* pa_core_get_source_output(pa_core *c, uint32_t idx) {
-    return pa_idxset_get_by_index(c->source_outputs, idx);
+    pa_source_output *e = pa_idxset_get_by_index(c->source_outputs, idx);
+
+    if (e == NULL || !pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SOURCE_OUTPUT, e->index, 0, NULL))
+      return NULL;
+
+    return e;
 }
 
 pa_scache_entry* pa_core_get_scache_entry(pa_core *c, uint32_t idx) {
-    return pa_idxset_get_by_index(c->scache, idx);
+    pa_scache_entry *e = pa_idxset_get_by_index(c->scache, idx);
+
+    if (e == NULL || !pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SAMPLE, e->index, 0, NULL))
+      return NULL;
+
+    return e;
 }
 
 const pa_sample_spec* pa_core_get_sample_spec(pa_core *c) {
diff --git a/src/pulsecore/core.h b/src/pulsecore/core.h
index 87b055d..316a88e 100644
--- a/src/pulsecore/core.h
+++ b/src/pulsecore/core.h
@@ -192,4 +192,8 @@ const pa_channel_map* pa_core_get_channel_map(pa_core *c);
 
 uint32_t pa_core_get_cookie(pa_core *c);
 
+bool pa_core_check_access_sync(pa_core *c, pa_access_hook_t hook, uint32_t idx, pa_subscription_event_type_t event, const char *name);
+
+pa_hook_result_t pa_core_check_access(pa_core *c, pa_access_data *data);
+
 #endif
diff --git a/src/pulsecore/module.c b/src/pulsecore/module.c
index da2abe0..bcc1a0e 100644
--- a/src/pulsecore/module.c
+++ b/src/pulsecore/module.c
@@ -120,6 +120,9 @@ pa_module* pa_module_load(pa_core *c, const char *name, const char *argument) {
     if (c->disallow_module_loading)
         goto fail;
 
+    if (!pa_core_check_access_sync(c, PA_ACCESS_HOOK_LOAD_MODULE, PA_INVALID_INDEX, 0, name))
+        goto fail;
+
     m = pa_xnew(pa_module, 1);
     m->name = pa_xstrdup(name);
     m->argument = pa_xstrdup(argument);
@@ -280,6 +283,9 @@ void pa_module_unload(pa_module *m, bool force) {
     if (m->core->disallow_module_loading && !force)
         return;
 
+    if (!pa_core_check_access_sync(m->core, PA_ACCESS_HOOK_UNLOAD_MODULE, m->index, 0, NULL))
+        return;
+
     if (!(m = pa_idxset_remove_by_data(m->core->modules, m, NULL)))
         return;
 
@@ -294,6 +300,9 @@ void pa_module_unload_by_index(pa_core *c, uint32_t idx, bool force) {
     if (c->disallow_module_loading && !force)
         return;
 
+    if (!pa_core_check_access_sync(c, PA_ACCESS_HOOK_UNLOAD_MODULE, idx, 0, NULL))
+        return;
+
     if (!(m = pa_idxset_remove_by_index(c->modules, idx)))
         return;
 
@@ -312,6 +321,9 @@ void pa_module_unload_all(pa_core *c) {
     if (pa_idxset_isempty(c->modules))
         return;
 
+    if (!pa_core_check_access_sync(c, PA_ACCESS_HOOK_UNLOAD_MODULE, PA_INVALID_INDEX, 0, NULL))
+        return;
+
     /* Unload modules in reverse order by default */
     indices = pa_xnew(uint32_t, pa_idxset_size(c->modules));
     i = 0;
@@ -357,6 +369,9 @@ void pa_module_unload_request(pa_module *m, bool force) {
     if (m->core->disallow_module_loading && !force)
         return;
 
+    if (!pa_core_check_access_sync(m->core, PA_ACCESS_HOOK_UNLOAD_MODULE, m->index, 0, NULL))
+        return;
+
     m->unload_requested = true;
     pa_hashmap_put(m->core->modules_pending_unload, m, m);
 
@@ -370,6 +385,9 @@ void pa_module_unload_request_by_index(pa_core *c, uint32_t idx, bool force) {
     pa_module *m;
     pa_assert(c);
 
+    if (!pa_core_check_access_sync(c, PA_ACCESS_HOOK_UNLOAD_MODULE, idx, 0, NULL))
+        return;
+
     if (!(m = pa_idxset_get_by_index(c->modules, idx)))
         return;
 
diff --git a/src/pulsecore/namereg.c b/src/pulsecore/namereg.c
index 699fa1b..fb68faf 100644
--- a/src/pulsecore/namereg.c
+++ b/src/pulsecore/namereg.c
@@ -232,9 +232,20 @@ void* pa_namereg_get(pa_core *c, const char *name, pa_namereg_type_t type) {
         !pa_namereg_is_valid_name(name))
         return NULL;
 
-    if ((e = pa_hashmap_get(c->namereg, name)))
-        if (e->type == type)
+    if ((e = pa_hashmap_get(c->namereg, name)) && e->type == type) {
+        if (type == PA_NAMEREG_SINK &&
+            pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SINK, ((pa_sink*)e->data)->index, 0, NULL))
             return e->data;
+        else if (type == PA_NAMEREG_SOURCE &&
+            pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SOURCE, ((pa_source*)e->data)->index, 0, NULL))
+            return e->data;
+        else if (type == PA_NAMEREG_SAMPLE &&
+            pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SAMPLE, ((pa_scache_entry*)e->data)->index, 0, NULL))
+            return e->data;
+        else if (type == PA_NAMEREG_CARD &&
+            pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_CARD, ((pa_card*)e->data)->index, 0, NULL))
+            return e->data;
+    }
 
     if (pa_atou(name, &idx) < 0)
         return NULL;
@@ -257,6 +268,9 @@ pa_sink* pa_namereg_set_default_sink(pa_core*c, pa_sink *s) {
     if (s && !PA_SINK_IS_LINKED(pa_sink_get_state(s)))
         return NULL;
 
+    if (s && !pa_core_check_access_sync(c, PA_ACCESS_HOOK_SET_DEFAULT_SINK, s->index, 0, NULL))
+        return NULL;
+
     if (c->default_sink != s) {
         c->default_sink = s;
         pa_core_hook_fire(c, PA_CORE_HOOK_DEFAULT_SINK_CHANGED, c->default_sink);
@@ -272,6 +286,9 @@ pa_source* pa_namereg_set_default_source(pa_core*c, pa_source *s) {
     if (s && !PA_SOURCE_IS_LINKED(pa_source_get_state(s)))
         return NULL;
 
+    if (s && !pa_core_check_access_sync(c, PA_ACCESS_HOOK_SET_DEFAULT_SOURCE, s->index, 0, NULL))
+        return NULL;
+
     if (c->default_source != s) {
         c->default_source = s;
         pa_core_hook_fire(c, PA_CORE_HOOK_DEFAULT_SOURCE_CHANGED, c->default_source);
@@ -288,7 +305,8 @@ pa_sink *pa_namereg_get_default_sink(pa_core *c) {
 
     pa_assert(c);
 
-    if (c->default_sink && PA_SINK_IS_LINKED(pa_sink_get_state(c->default_sink)))
+    if (c->default_sink && PA_SINK_IS_LINKED(pa_sink_get_state(c->default_sink)) &&
+        pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SINK, c->default_sink->index, 0, NULL))
         return c->default_sink;
 
     sinks = pa_core_get_sinks(c);
@@ -310,7 +328,8 @@ pa_source *pa_namereg_get_default_source(pa_core *c) {
 
     pa_assert(c);
 
-    if (c->default_source && PA_SOURCE_IS_LINKED(pa_source_get_state(c->default_source)))
+    if (c->default_source && PA_SOURCE_IS_LINKED(pa_source_get_state(c->default_source)) &&
+        pa_core_check_access_sync(c, PA_ACCESS_HOOK_VIEW_SOURCE, c->default_source->index, 0, NULL))
         return c->default_source;
 
     sources = pa_core_get_sources(c);
diff --git a/src/pulsecore/protocol-native.c b/src/pulsecore/protocol-native.c
index 4cae6df..4ff97c4 100644
--- a/src/pulsecore/protocol-native.c
+++ b/src/pulsecore/protocol-native.c
@@ -45,6 +45,7 @@
 #include <pulsecore/pdispatch.h>
 #include <pulsecore/pstream-util.h>
 #include <pulsecore/namereg.h>
+#include <pulsecore/access.h>
 #include <pulsecore/core-scache.h>
 #include <pulsecore/core-subscribe.h>
 #include <pulsecore/log.h>
diff --git a/src/pulsecore/sink-input.c b/src/pulsecore/sink-input.c
index 9a866b4..00c370a 100644
--- a/src/pulsecore/sink-input.c
+++ b/src/pulsecore/sink-input.c
@@ -297,6 +297,9 @@ int pa_sink_input_new(
     pa_assert(data);
     pa_assert_ctl_context();
 
+    if (!pa_core_check_access_sync(core, PA_ACCESS_HOOK_CREATE_SINK_INPUT, PA_INVALID_INDEX, 0, NULL))
+        return -PA_ERR_ACCESS;
+
     if (data->client)
         pa_proplist_update(data->proplist, PA_UPDATE_MERGE, data->client->proplist);
 
@@ -811,6 +814,9 @@ void pa_sink_input_kill(pa_sink_input*i) {
     pa_assert_ctl_context();
     pa_assert(PA_SINK_INPUT_IS_LINKED(i->state));
 
+    if (!pa_core_check_access_sync(i->core, PA_ACCESS_HOOK_KILL_SINK_INPUT, i->index, 0, NULL))
+        return;
+
     i->kill(i);
 }
 
@@ -1238,6 +1244,9 @@ void pa_sink_input_set_volume(pa_sink_input *i, const pa_cvolume *volume, bool s
     pa_assert(volume->channels == 1 || pa_cvolume_compatible(volume, &i->sample_spec));
     pa_assert(i->volume_writable);
 
+    if (!pa_core_check_access_sync(i->core, PA_ACCESS_HOOK_SET_SINK_INPUT_VOLUME, i->index, 0, NULL))
+        return;
+
     if (!absolute && pa_sink_flat_volume_enabled(i->sink)) {
         v = i->sink->reference_volume;
         pa_cvolume_remap(&v, &i->sink->channel_map, &i->channel_map);
@@ -1289,6 +1298,9 @@ void pa_sink_input_add_volume_factor(pa_sink_input *i, const char *key, const pa
     pa_assert(pa_cvolume_valid(volume_factor));
     pa_assert(volume_factor->channels == 1 || pa_cvolume_compatible(volume_factor, &i->sample_spec));
 
+    if (!pa_core_check_access_sync(i->core, PA_ACCESS_HOOK_SET_SINK_INPUT_VOLUME, i->index, 0, NULL))
+        return;
+
     v = volume_factor_entry_new(key, volume_factor);
     if (!pa_cvolume_compatible(volume_factor, &i->sample_spec))
         pa_cvolume_set(&v->volume, i->sample_spec.channels, volume_factor->values[0]);
@@ -1315,6 +1327,9 @@ int pa_sink_input_remove_volume_factor(pa_sink_input *i, const char *key) {
     pa_assert_ctl_context();
     pa_assert(PA_SINK_INPUT_IS_LINKED(i->state));
 
+    if (!pa_core_check_access_sync(i->core, PA_ACCESS_HOOK_SET_SINK_INPUT_VOLUME, i->index, 0, NULL))
+        return -1;
+
     if (pa_hashmap_remove_and_free(i->volume_factor_items, key) < 0)
         return -1;
 
@@ -1403,6 +1418,9 @@ void pa_sink_input_set_mute(pa_sink_input *i, bool mute, bool save) {
     pa_assert_ctl_context();
     pa_assert(PA_SINK_INPUT_IS_LINKED(i->state));
 
+    if (!pa_core_check_access_sync(i->core, PA_ACCESS_HOOK_SET_SINK_INPUT_VOLUME, i->index, 0, NULL))
+        return;
+
     old_mute = i->muted;
 
     if (mute == old_mute) {
@@ -1625,6 +1643,12 @@ bool pa_sink_input_may_move_to(pa_sink_input *i, pa_sink *dest) {
     if (!pa_sink_input_may_move(i))
         return false;
 
+    if (!pa_core_check_access_sync(i->core, PA_ACCESS_HOOK_MOVE_SINK_INPUT, i->index, 0, NULL))
+        return false;
+
+    if (!pa_core_check_access_sync(i->core, PA_ACCESS_HOOK_VIEW_SINK, dest->index, 0, NULL))
+        return false;
+
     /* Make sure we're not creating a filter sink cycle */
     if (find_filter_sink_input(i, dest)) {
         pa_log_debug("Can't connect input to %s, as that would create a cycle.", dest->name);
@@ -2332,6 +2356,9 @@ void pa_sink_input_set_volume_direct(pa_sink_input *i, const pa_cvolume *volume)
     pa_assert(i);
     pa_assert(volume);
 
+    if (!pa_core_check_access_sync(i->core, PA_ACCESS_HOOK_SET_SINK_INPUT_VOLUME, i->index, 0, NULL))
+        return;
+
     old_volume = i->volume;
 
     if (pa_cvolume_equal(volume, &old_volume))
diff --git a/src/pulsecore/sink.c b/src/pulsecore/sink.c
index a5cb1ee..891c55c 100644
--- a/src/pulsecore/sink.c
+++ b/src/pulsecore/sink.c
@@ -839,6 +839,9 @@ int pa_sink_suspend(pa_sink *s, bool suspend, pa_suspend_cause_t cause) {
     pa_assert(PA_SINK_IS_LINKED(s->state));
     pa_assert(cause != 0);
 
+    if (!pa_core_check_access_sync (s->core, PA_ACCESS_HOOK_SUSPEND_SINK, s->index, 0, NULL))
+        return -PA_ERR_ACCESS;
+
     if (suspend) {
         s->suspend_cause |= cause;
         s->monitor_source->suspend_cause |= cause;
@@ -1610,6 +1613,9 @@ bool pa_sink_is_passthrough(pa_sink *s) {
 void pa_sink_enter_passthrough(pa_sink *s) {
     pa_cvolume volume;
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_ENTER_PASSTHROUGH_SINK, s->index, 0, NULL))
+        return;
+
     /* disable the monitor in passthrough mode */
     if (s->monitor_source) {
         pa_log_debug("Suspending monitor source %s, because the sink is entering the passthrough mode.", s->monitor_source->name);
@@ -1626,6 +1632,10 @@ void pa_sink_enter_passthrough(pa_sink *s) {
 
 /* Called from main context */
 void pa_sink_leave_passthrough(pa_sink *s) {
+
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_LEAVE_PASSTHROUGH_SINK, s->index, 0, NULL))
+        return;
+
     /* Unsuspend monitor */
     if (s->monitor_source) {
         pa_log_debug("Resuming monitor source %s, because the sink is leaving the passthrough mode.", s->monitor_source->name);
@@ -2013,6 +2023,9 @@ void pa_sink_set_volume(
     pa_assert(volume || pa_sink_flat_volume_enabled(s));
     pa_assert(!volume || volume->channels == 1 || pa_cvolume_compatible(volume, &s->sample_spec));
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_SET_SINK_VOLUME, s->index, 0, NULL))
+        return;
+
     /* make sure we don't change the volume when a PASSTHROUGH input is connected ...
      * ... *except* if we're being invoked to reset the volume to ensure 0 dB gain */
     if (pa_sink_is_passthrough(s) && (!volume || !pa_cvolume_is_norm(volume))) {
@@ -2229,6 +2242,9 @@ void pa_sink_set_mute(pa_sink *s, bool mute, bool save) {
     pa_sink_assert_ref(s);
     pa_assert_ctl_context();
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_SET_SINK_VOLUME, s->index, 0, NULL))
+        return;
+
     old_muted = s->muted;
 
     if (mute == old_muted) {
@@ -3280,6 +3296,9 @@ void pa_sink_set_fixed_latency_within_thread(pa_sink *s, pa_usec_t latency) {
 void pa_sink_set_port_latency_offset(pa_sink *s, int64_t offset) {
     pa_sink_assert_ref(s);
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_SET_SINK_PORT_LATENCY_OFFSET, s->index, 0, NULL))
+        return;
+
     s->port_latency_offset = offset;
 
     if (PA_SINK_IS_LINKED(s->state))
@@ -3332,6 +3351,9 @@ int pa_sink_set_port(pa_sink *s, const char *name, bool save) {
     if (!name)
         return -PA_ERR_NOENTITY;
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_SET_SINK_PORT, s->index, 0, name))
+        return -PA_ERR_ACCESS;
+
     if (!(port = pa_hashmap_get(s->ports, name)))
         return -PA_ERR_NOENTITY;
 
diff --git a/src/pulsecore/sound-file-stream.c b/src/pulsecore/sound-file-stream.c
index 3ac935d..985de6b 100644
--- a/src/pulsecore/sound-file-stream.c
+++ b/src/pulsecore/sound-file-stream.c
@@ -242,6 +242,9 @@ int pa_play_file(
     pa_assert(sink);
     pa_assert(fname);
 
+    if (!pa_core_check_access_sync (sink->core, PA_ACCESS_HOOK_PLAY_FILE, PA_INVALID_INDEX, 0, fname))
+        return -1;
+
     u = pa_msgobject_new(file_stream);
     u->parent.parent.free = file_stream_free;
     u->parent.process_msg = file_stream_process_msg;
diff --git a/src/pulsecore/source-output.c b/src/pulsecore/source-output.c
index a265e6f..872ee27 100644
--- a/src/pulsecore/source-output.c
+++ b/src/pulsecore/source-output.c
@@ -231,6 +231,9 @@ int pa_source_output_new(
     pa_assert(data);
     pa_assert_ctl_context();
 
+    if (!pa_core_check_access_sync(core, PA_ACCESS_HOOK_CREATE_SOURCE_OUTPUT, PA_INVALID_INDEX, 0, NULL))
+        return -PA_ERR_ACCESS;
+
     if (data->client)
         pa_proplist_update(data->proplist, PA_UPDATE_MERGE, data->client->proplist);
 
@@ -687,6 +690,9 @@ void pa_source_output_kill(pa_source_output*o) {
     pa_assert_ctl_context();
     pa_assert(PA_SOURCE_OUTPUT_IS_LINKED(o->state));
 
+    if (!pa_core_check_access_sync(o->core, PA_ACCESS_HOOK_KILL_SOURCE_OUTPUT, o->index, 0, NULL))
+        return;
+
     o->kill(o);
 }
 
@@ -945,6 +951,9 @@ void pa_source_output_set_volume(pa_source_output *o, const pa_cvolume *volume,
     pa_assert(volume->channels == 1 || pa_cvolume_compatible(volume, &o->sample_spec));
     pa_assert(o->volume_writable);
 
+    if (!pa_core_check_access_sync(o->core, PA_ACCESS_HOOK_SET_SOURCE_OUTPUT_VOLUME, o->index, 0, NULL))
+        return;
+
     if (!absolute && pa_source_flat_volume_enabled(o->source)) {
         v = o->source->reference_volume;
         pa_cvolume_remap(&v, &o->source->channel_map, &o->channel_map);
@@ -1056,6 +1065,9 @@ void pa_source_output_set_mute(pa_source_output *o, bool mute, bool save) {
     pa_assert_ctl_context();
     pa_assert(PA_SOURCE_OUTPUT_IS_LINKED(o->state));
 
+    if (!pa_core_check_access_sync(o->core, PA_ACCESS_HOOK_SET_SINK_INPUT_VOLUME, o->index, 0, NULL))
+        return;
+
     old_mute = o->muted;
 
     if (mute == old_mute) {
@@ -1275,6 +1287,12 @@ bool pa_source_output_may_move_to(pa_source_output *o, pa_source *dest) {
     if (!pa_source_output_may_move(o))
         return false;
 
+    if (!pa_core_check_access_sync(o->core, PA_ACCESS_HOOK_MOVE_SOURCE_OUTPUT, o->index, 0, NULL))
+        return false;
+
+    if (!pa_core_check_access_sync(o->core, PA_ACCESS_HOOK_VIEW_SOURCE, dest->index, 0, NULL))
+        return false;
+
     /* Make sure we're not creating a filter source cycle */
     if (find_filter_source_output(o, dest)) {
         pa_log_debug("Can't connect output to %s, as that would create a cycle.", dest->name);
@@ -1787,6 +1805,9 @@ void pa_source_output_set_volume_direct(pa_source_output *o, const pa_cvolume *v
     pa_assert(o);
     pa_assert(volume);
 
+    if (!pa_core_check_access_sync(o->core, PA_ACCESS_HOOK_SET_SOURCE_OUTPUT_VOLUME, o->index, 0, NULL))
+        return;
+
     old_volume = o->volume;
 
     if (pa_cvolume_equal(volume, &old_volume))
diff --git a/src/pulsecore/source.c b/src/pulsecore/source.c
index 5f42965..449aeff 100644
--- a/src/pulsecore/source.c
+++ b/src/pulsecore/source.c
@@ -763,6 +763,9 @@ int pa_source_suspend(pa_source *s, bool suspend, pa_suspend_cause_t cause) {
     if (s->monitor_of && cause != PA_SUSPEND_PASSTHROUGH)
         return -PA_ERR_NOTSUPPORTED;
 
+    if (!pa_core_check_access_sync (s->core, PA_ACCESS_HOOK_SUSPEND_SOURCE, s->index, 0, NULL))
+        return -PA_ERR_ACCESS;
+
     if (suspend)
         s->suspend_cause |= cause;
     else
@@ -1196,6 +1199,9 @@ bool pa_source_is_passthrough(pa_source *s) {
 void pa_source_enter_passthrough(pa_source *s) {
     pa_cvolume volume;
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_ENTER_PASSTHROUGH_SOURCE, s->index, 0, NULL))
+        return;
+
     /* set the volume to NORM */
     s->saved_volume = *pa_source_get_volume(s, true);
     s->saved_save_volume = s->save_volume;
@@ -1206,6 +1212,9 @@ void pa_source_enter_passthrough(pa_source *s) {
 
 /* Called from main context */
 void pa_source_leave_passthrough(pa_source *s) {
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_LEAVE_PASSTHROUGH_SOURCE, s->index, 0, NULL))
+        return;
+
     /* Restore source volume to what it was before we entered passthrough mode */
     pa_source_set_volume(s, &s->saved_volume, true, s->saved_save_volume);
 
@@ -1587,6 +1596,9 @@ void pa_source_set_volume(
     pa_assert(volume || pa_source_flat_volume_enabled(s));
     pa_assert(!volume || volume->channels == 1 || pa_cvolume_compatible(volume, &s->sample_spec));
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_SET_SOURCE_VOLUME, s->index, 0, NULL))
+        return;
+
     /* make sure we don't change the volume in PASSTHROUGH mode ...
      * ... *except* if we're being invoked to reset the volume to ensure 0 dB gain */
     if (pa_source_is_passthrough(s) && (!volume || !pa_cvolume_is_norm(volume))) {
@@ -1812,6 +1824,9 @@ void pa_source_set_mute(pa_source *s, bool mute, bool save) {
     pa_source_assert_ref(s);
     pa_assert_ctl_context();
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_SET_SOURCE_VOLUME, s->index, 0, NULL))
+        return;
+
     old_muted = s->muted;
 
     if (mute == old_muted) {
@@ -2571,6 +2586,9 @@ void pa_source_set_fixed_latency_within_thread(pa_source *s, pa_usec_t latency)
 void pa_source_set_port_latency_offset(pa_source *s, int64_t offset) {
     pa_source_assert_ref(s);
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_SET_SOURCE_PORT_LATENCY_OFFSET, s->index, 0, NULL))
+        return;
+
     s->port_latency_offset = offset;
 
     if (PA_SOURCE_IS_LINKED(s->state))
@@ -2609,6 +2627,9 @@ int pa_source_set_port(pa_source *s, const char *name, bool save) {
     if (!name)
         return -PA_ERR_NOENTITY;
 
+    if (!pa_core_check_access_sync(s->core, PA_ACCESS_HOOK_SET_SOURCE_PORT, s->index, 0, name))
+        return -PA_ERR_ACCESS;
+
     if (!(port = pa_hashmap_get(s->ports, name)))
         return -PA_ERR_NOENTITY;
 
-- 
2.9.3

