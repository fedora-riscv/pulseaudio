diff --git a/src/Makefile.am b/src/Makefile.am
index 1fc8735..f5a1feb 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1315,7 +1315,7 @@ endif
 
 if HAVE_DBUS
 libalsa_util_la_SOURCES += modules/reserve.h modules/reserve.c modules/reserve-wrap.c modules/reserve-wrap.h
-libalsa_util_la_LIBADD += $(DBUS_LIBS)
+libalsa_util_la_LIBADD += $(DBUS_LIBS) libdbus-util.la
 libalsa_util_la_CFLAGS += $(DBUS_CFLAGS)
 endif
 
@@ -1532,7 +1532,7 @@ libbluetooth_util_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS)
 
 module_bluetooth_device_la_SOURCES = modules/bluetooth/module-bluetooth-device.c modules/bluetooth/rtp.h
 module_bluetooth_device_la_LDFLAGS = $(MODULE_LDFLAGS)
-module_bluetooth_device_la_LIBADD = $(AM_LIBADD) $(DBUS_LIBS) libpulsecore-@PA_MAJORMINORMICRO@.la libdbus-util.la libbluetooth-ipc.la libbluetooth-sbc.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
+module_bluetooth_device_la_LIBADD = $(AM_LIBADD) $(DBUS_LIBS) libpulsecore-@PA_MAJORMINORMICRO@.la libdbus-util.la libbluetooth-util.la libbluetooth-ipc.la libbluetooth-sbc.la libpulsecommon-@PA_MAJORMINORMICRO@.la libpulse.la
 module_bluetooth_device_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS)
 
 # Apple Airtunes/RAOP
diff --git a/src/modules/alsa/alsa-sink.c b/src/modules/alsa/alsa-sink.c
index dbd95b6..0aef1bd 100644
--- a/src/modules/alsa/alsa-sink.c
+++ b/src/modules/alsa/alsa-sink.c
@@ -61,10 +61,11 @@
 /* #define DEBUG_TIMING */
 
 #define DEFAULT_DEVICE "default"
-#define DEFAULT_TSCHED_BUFFER_USEC (2*PA_USEC_PER_SEC)            /* 2s */
-#define DEFAULT_TSCHED_WATERMARK_USEC (20*PA_USEC_PER_MSEC)       /* 20ms */
-#define TSCHED_MIN_SLEEP_USEC (10*PA_USEC_PER_MSEC)               /* 10ms */
-#define TSCHED_MIN_WAKEUP_USEC (4*PA_USEC_PER_MSEC)               /* 4ms */
+#define DEFAULT_TSCHED_BUFFER_USEC (2*PA_USEC_PER_SEC)            /* 2s   -- Overall buffer size */
+#define DEFAULT_TSCHED_WATERMARK_USEC (20*PA_USEC_PER_MSEC)       /* 20ms -- Fill up when only this much is left in the buffer */
+#define TSCHED_WATERMARK_STEP_USEC (10*PA_USEC_PER_MSEC)          /* 10ms -- On underrun, increase watermark by this */
+#define TSCHED_MIN_SLEEP_USEC (10*PA_USEC_PER_MSEC)               /* 10ms -- Sleep at least 10ms on each iteration */
+#define TSCHED_MIN_WAKEUP_USEC (4*PA_USEC_PER_MSEC)               /* 4ms  -- Wakeup at least this long before the buffer runs empty*/
 
 struct userdata {
     pa_core *core;
@@ -86,7 +87,16 @@ struct userdata {
     pa_bool_t mixer_seperate_channels:1;
     pa_cvolume hardware_volume;
 
-    size_t frame_size, fragment_size, hwbuf_size, tsched_watermark, hwbuf_unused, min_sleep, min_wakeup;
+    size_t
+        frame_size,
+        fragment_size,
+        hwbuf_size,
+        tsched_watermark,
+        hwbuf_unused,
+        min_sleep,
+        min_wakeup,
+        watermark_step;
+
     unsigned nfragments;
     pa_memchunk memchunk;
 
@@ -205,10 +215,11 @@ static void adjust_after_underrun(struct userdata *u) {
     pa_usec_t old_min_latency, new_min_latency;
 
     pa_assert(u);
+    pa_assert(u->use_tsched);
 
     /* First, just try to increase the watermark */
     old_watermark = u->tsched_watermark;
-    u->tsched_watermark *= 2;
+    u->tsched_watermark = PA_MIN(u->tsched_watermark * 2, u->tsched_watermark + u->watermark_step);
     fix_tsched_watermark(u);
 
     if (old_watermark != u->tsched_watermark) {
@@ -219,7 +230,8 @@ static void adjust_after_underrun(struct userdata *u) {
 
     /* Hmm, we cannot increase the watermark any further, hence let's raise the latency */
     old_min_latency = u->sink->thread_info.min_latency;
-    new_min_latency = PA_MIN(old_min_latency * 2, u->sink->thread_info.max_latency);
+    new_min_latency = PA_MIN(old_min_latency * 2, old_min_latency + TSCHED_WATERMARK_STEP_USEC);
+    new_min_latency = PA_MIN(new_min_latency, u->sink->thread_info.max_latency);
 
     if (old_min_latency != new_min_latency) {
         pa_log_notice("Increasing minimal latency to %0.2f ms",
@@ -1484,7 +1496,7 @@ pa_sink *pa_alsa_sink_new(pa_module *m, pa_modargs *ma, const char*driver, pa_ca
 
     struct userdata *u = NULL;
     const char *dev_id = NULL;
-    pa_sample_spec ss;
+    pa_sample_spec ss, requested_ss;
     pa_channel_map map;
     uint32_t nfrags, hwbuf_size, frag_size, tsched_size, tsched_watermark;
     snd_pcm_uframes_t period_frames, tsched_frames;
@@ -1503,6 +1515,7 @@ pa_sink *pa_alsa_sink_new(pa_module *m, pa_modargs *ma, const char*driver, pa_ca
         goto fail;
     }
 
+    requested_ss = ss;
     frame_size = pa_frame_size(&ss);
 
     nfrags = m->core->default_n_fragments;
@@ -1674,12 +1687,14 @@ pa_sink *pa_alsa_sink_new(pa_module *m, pa_modargs *ma, const char*driver, pa_ca
     u->fragment_size = frag_size = (uint32_t) (period_frames * frame_size);
     u->nfragments = nfrags;
     u->hwbuf_size = u->fragment_size * nfrags;
-    u->tsched_watermark = tsched_watermark;
+    u->tsched_watermark = pa_usec_to_bytes_round_up(pa_bytes_to_usec_round_up(tsched_watermark, &requested_ss), &u->sink->sample_spec);
     pa_cvolume_mute(&u->hardware_volume, u->sink->sample_spec.channels);
 
     if (use_tsched) {
         fix_min_sleep_wakeup(u);
         fix_tsched_watermark(u);
+
+        u->watermark_step = pa_usec_to_bytes(TSCHED_WATERMARK_STEP_USEC, &u->sink->sample_spec);
     }
 
     u->sink->thread_info.max_rewind = use_tsched ? u->hwbuf_size : 0;
diff --git a/src/modules/alsa/alsa-source.c b/src/modules/alsa/alsa-source.c
index 39df4a9..671df3f 100644
--- a/src/modules/alsa/alsa-source.c
+++ b/src/modules/alsa/alsa-source.c
@@ -64,6 +64,7 @@
 #define DEFAULT_DEVICE "default"
 #define DEFAULT_TSCHED_BUFFER_USEC (2*PA_USEC_PER_SEC)       /* 2s */
 #define DEFAULT_TSCHED_WATERMARK_USEC (20*PA_USEC_PER_MSEC)  /* 20ms */
+#define TSCHED_WATERMARK_STEP_USEC (10*PA_USEC_PER_MSEC)     /* 10ms */
 #define TSCHED_MIN_SLEEP_USEC (10*PA_USEC_PER_MSEC)          /* 10ms */
 #define TSCHED_MIN_WAKEUP_USEC (4*PA_USEC_PER_MSEC)          /* 4ms */
 
@@ -88,7 +89,16 @@ struct userdata {
 
     pa_cvolume hardware_volume;
 
-    size_t frame_size, fragment_size, hwbuf_size, tsched_watermark, hwbuf_unused, min_sleep, min_wakeup;
+    size_t
+        frame_size,
+        fragment_size,
+        hwbuf_size,
+        tsched_watermark,
+        hwbuf_unused,
+        min_sleep,
+        min_wakeup,
+        watermark_step;
+
     unsigned nfragments;
 
     char *device_name;
@@ -202,10 +212,12 @@ static void adjust_after_overrun(struct userdata *u) {
     pa_usec_t old_min_latency, new_min_latency;
 
     pa_assert(u);
+    pa_assert(u->use_tsched);
 
     /* First, just try to increase the watermark */
     old_watermark = u->tsched_watermark;
-    u->tsched_watermark *= 2;
+    u->tsched_watermark = PA_MIN(u->tsched_watermark * 2, u->tsched_watermark + u->watermark_step);
+
     fix_tsched_watermark(u);
 
     if (old_watermark != u->tsched_watermark) {
@@ -216,7 +228,8 @@ static void adjust_after_overrun(struct userdata *u) {
 
     /* Hmm, we cannot increase the watermark any further, hence let's raise the latency */
     old_min_latency = u->source->thread_info.min_latency;
-    new_min_latency = PA_MIN(old_min_latency * 2, u->source->thread_info.max_latency);
+    new_min_latency = PA_MIN(old_min_latency * 2, old_min_latency + TSCHED_WATERMARK_STEP_USEC);
+    new_min_latency = PA_MIN(new_min_latency, u->source->thread_info.max_latency);
 
     if (old_min_latency != new_min_latency) {
         pa_log_notice("Increasing minimal latency to %0.2f ms",
@@ -1331,7 +1344,7 @@ pa_source *pa_alsa_source_new(pa_module *m, pa_modargs *ma, const char*driver, p
 
     struct userdata *u = NULL;
     const char *dev_id = NULL;
-    pa_sample_spec ss;
+    pa_sample_spec ss, requested_ss;
     pa_channel_map map;
     uint32_t nfrags, hwbuf_size, frag_size, tsched_size, tsched_watermark;
     snd_pcm_uframes_t period_frames, tsched_frames;
@@ -1349,6 +1362,7 @@ pa_source *pa_alsa_source_new(pa_module *m, pa_modargs *ma, const char*driver, p
         goto fail;
     }
 
+    requested_ss = ss;
     frame_size = pa_frame_size(&ss);
 
     nfrags = m->core->default_n_fragments;
@@ -1515,12 +1529,14 @@ pa_source *pa_alsa_source_new(pa_module *m, pa_modargs *ma, const char*driver, p
     u->fragment_size = frag_size = (uint32_t) (period_frames * frame_size);
     u->nfragments = nfrags;
     u->hwbuf_size = u->fragment_size * nfrags;
-    u->tsched_watermark = tsched_watermark;
+    u->tsched_watermark = pa_usec_to_bytes_round_up(pa_bytes_to_usec_round_up(tsched_watermark, &requested_ss), &u->source->sample_spec);
     pa_cvolume_mute(&u->hardware_volume, u->source->sample_spec.channels);
 
     if (use_tsched) {
         fix_min_sleep_wakeup(u);
         fix_tsched_watermark(u);
+
+        u->watermark_step = pa_usec_to_bytes(TSCHED_WATERMARK_STEP_USEC, &u->source->sample_spec);
     }
 
     pa_source_set_latency_range(u->source,
diff --git a/src/pulse/proplist.h b/src/pulse/proplist.h
index d30dc3b..fa44c42 100644
--- a/src/pulse/proplist.h
+++ b/src/pulse/proplist.h
@@ -156,7 +156,7 @@ PA_C_DECL_BEGIN
 /** For devices: device class. One of "sound", "modem", "monitor", "filter" */
 #define PA_PROP_DEVICE_CLASS                   "device.class"
 
-/** For devices: form factor if applicable. One of "laptop-speakers", "external-speakers", "telephone", "tv-capture", "webcam-capture", "microphone-capture", "headset", "headphones", "hands-free", "car", "hifi", "computer", "portable" */
+/** For devices: form factor if applicable. One of "internal-speakers", "external-speakers", "handset", "tv-capture", "webcam", "microphone", "headset", "headphones", "hands-free", "car", "hifi", "computer", "portable" */
 #define PA_PROP_DEVICE_FORM_FACTOR             "device.form_factor"
 
 /** For devices: connector of the device if applicable. One of "isa", "pci", "usb", "firewire", "bluetooth" */
diff --git a/src/pulsecore/core.c b/src/pulsecore/core.c
index eef967a..c064e67 100644
--- a/src/pulsecore/core.c
+++ b/src/pulsecore/core.c
@@ -250,3 +250,14 @@ int pa_core_exit(pa_core *c, pa_bool_t force, int retval) {
     c->mainloop->quit(c->mainloop, retval);
     return 0;
 }
+
+void pa_core_maybe_vacuum(pa_core *c) {
+    pa_assert(c);
+
+    if (!pa_idxset_isempty(c->sink_inputs) ||
+        !pa_idxset_isempty(c->source_outputs))
+        return;
+
+    pa_log_debug("Hmm, no streams around, trying to vacuum.");
+    pa_mempool_vacuum(c->mempool);
+}
diff --git a/src/pulsecore/core.h b/src/pulsecore/core.h
index 7660bd3..093fa8f 100644
--- a/src/pulsecore/core.h
+++ b/src/pulsecore/core.h
@@ -171,4 +171,6 @@ void pa_core_check_idle(pa_core *c);
 
 int pa_core_exit(pa_core *c, pa_bool_t force, int retval);
 
+void pa_core_maybe_vacuum(pa_core *c);
+
 #endif
diff --git a/src/pulsecore/sink-input.c b/src/pulsecore/sink-input.c
index 544bb33..34de9bb 100644
--- a/src/pulsecore/sink-input.c
+++ b/src/pulsecore/sink-input.c
@@ -468,6 +468,8 @@ void pa_sink_input_unlink(pa_sink_input *i) {
         i->sink = NULL;
     }
 
+    pa_core_maybe_vacuum(i->core);
+
     pa_sink_input_unref(i);
 }
 
diff --git a/src/pulsecore/source-output.c b/src/pulsecore/source-output.c
index d8a2363..d99f79c 100644
--- a/src/pulsecore/source-output.c
+++ b/src/pulsecore/source-output.c
@@ -335,6 +335,8 @@ void pa_source_output_unlink(pa_source_output*o) {
         o->source = NULL;
     }
 
+    pa_core_maybe_vacuum(o->core);
+
     pa_source_output_unref(o);
 }
 
