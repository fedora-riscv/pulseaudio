From 09279f76342a1f3b261c04232821c3dc225312c3 Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Wed, 22 Oct 2008 23:55:52 +0200
Subject: [PATCH] warn if ALSA wakes us up and there is actually nothing to do

---
 src/modules/alsa-util.c          |    6 +++++
 src/modules/module-alsa-sink.c   |   41 +++++++++++++++++++++++++++----------
 src/modules/module-alsa-source.c |   41 +++++++++++++++++++++++++++----------
 3 files changed, 66 insertions(+), 22 deletions(-)

diff --git a/src/modules/alsa-util.c b/src/modules/alsa-util.c
index 39cea49..20dc400 100644
--- a/src/modules/alsa-util.c
+++ b/src/modules/alsa-util.c
@@ -1051,6 +1051,12 @@ int pa_alsa_recover_from_poll(snd_pcm_t *pcm, int revents) {
         pa_log_warn("Got POLLNVAL from ALSA");
     if (revents & POLLHUP)
         pa_log_warn("Got POLLHUP from ALSA");
+    if (revents & POLLPRI)
+        pa_log_warn("Got POLLPRI from ALSA");
+    if (revents & POLLIN)
+        pa_log_warn("Got POLLIN from ALSA");
+    if (revents & POLLOUT)
+        pa_log_warn("Got POLLOUT from ALSA");
 
     state = snd_pcm_state(pcm);
     pa_log_warn("PCM state is %s", snd_pcm_state_name(state));
diff --git a/src/modules/module-alsa-sink.c b/src/modules/module-alsa-sink.c
index af83103..6dea172 100644
--- a/src/modules/module-alsa-sink.c
+++ b/src/modules/module-alsa-sink.c
@@ -241,7 +241,7 @@ static size_t check_left_to_play(struct userdata *u, snd_pcm_sframes_t n) {
     return left_to_play;
 }
 
-static int mmap_write(struct userdata *u, pa_usec_t *sleep_usec) {
+static int mmap_write(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polled) {
     int work_done = 0;
     pa_usec_t max_sleep_usec = 0, process_usec = 0;
     size_t left_to_play;
@@ -279,14 +279,23 @@ static int mmap_write(struct userdata *u, pa_usec_t *sleep_usec) {
             * need to guarantee that clients only have to keep around
             * a single hw buffer length. */
 
-            if (pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
+            if (!polled &&
+                pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames))
+        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames)) {
+
+            if (polled)
+                pa_log("ALSA woke us up to write new data to the device, but there was actually nothing to write! "
+                       "Most likely this is an ALSA driver bug. Please report this issue to the PulseAudio developers.");
+
             break;
+        }
 
         n -= u->hwbuf_unused_frames;
 
+        polled = FALSE;
+
 /*         pa_log_debug("Filling up"); */
 
         for (;;) {
@@ -357,7 +366,7 @@ static int mmap_write(struct userdata *u, pa_usec_t *sleep_usec) {
     return work_done;
 }
 
-static int unix_write(struct userdata *u, pa_usec_t *sleep_usec) {
+static int unix_write(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polled) {
     int work_done = 0;
     pa_usec_t max_sleep_usec = 0, process_usec = 0;
     size_t left_to_play;
@@ -392,14 +401,23 @@ static int unix_write(struct userdata *u, pa_usec_t *sleep_usec) {
             * need to guarantee that clients only have to keep around
             * a single hw buffer length. */
 
-            if (pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
+            if (!polled &&
+                pa_bytes_to_usec(left_to_play, &u->sink->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames))
+        if (PA_UNLIKELY(n <= u->hwbuf_unused_frames)) {
+
+            if (polled)
+                pa_log("ALSA woke us up to write new data to the device, but there was actually nothing to write! "
+                       "Most likely this is an ALSA driver bug. Please report this issue to the PulseAudio developers.");
+
             break;
+        }
 
         n -= u->hwbuf_unused_frames;
 
+        polled = FALSE;
+
         for (;;) {
             snd_pcm_sframes_t frames;
             void *p;
@@ -1084,6 +1102,7 @@ finish:
 
 static void thread_func(void *userdata) {
     struct userdata *u = userdata;
+    unsigned short revents = 0;
 
     pa_assert(u);
 
@@ -1110,9 +1129,9 @@ static void thread_func(void *userdata) {
                         goto fail;
 
             if (u->use_mmap)
-                work_done = mmap_write(u, &sleep_usec);
+                work_done = mmap_write(u, &sleep_usec, revents & POLLOUT);
             else
-                work_done = unix_write(u, &sleep_usec);
+                work_done = unix_write(u, &sleep_usec, revents & POLLOUT);
 
             if (work_done < 0)
                 goto fail;
@@ -1180,7 +1199,6 @@ static void thread_func(void *userdata) {
         /* Tell ALSA about this and process its response */
         if (PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
             struct pollfd *pollfd;
-            unsigned short revents = 0;
             int err;
             unsigned n;
 
@@ -1191,7 +1209,7 @@ static void thread_func(void *userdata) {
                 goto fail;
             }
 
-            if (revents & (POLLERR|POLLNVAL|POLLHUP|POLLPRI)) {
+            if (revents & (POLLIN|POLLERR|POLLNVAL|POLLHUP|POLLPRI)) {
                 if (pa_alsa_recover_from_poll(u->pcm_handle, revents) < 0)
                     goto fail;
 
@@ -1201,7 +1219,8 @@ static void thread_func(void *userdata) {
 
             if (revents && u->use_tsched)
                 pa_log_debug("Wakeup from ALSA!%s%s", (revents & POLLIN) ? " INPUT" : "", (revents & POLLOUT) ? " OUTPUT" : "");
-        }
+        } else
+            revents = 0;
     }
 
 fail:
diff --git a/src/modules/module-alsa-source.c b/src/modules/module-alsa-source.c
index dd6ca97..f796ef1 100644
--- a/src/modules/module-alsa-source.c
+++ b/src/modules/module-alsa-source.c
@@ -238,7 +238,7 @@ static size_t check_left_to_record(struct userdata *u, snd_pcm_sframes_t n) {
     return left_to_record;
 }
 
-static int mmap_read(struct userdata *u, pa_usec_t *sleep_usec) {
+static int mmap_read(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polled) {
     int work_done = 0;
     pa_usec_t max_sleep_usec = 0, process_usec = 0;
     size_t left_to_record;
@@ -266,11 +266,20 @@ static int mmap_read(struct userdata *u, pa_usec_t *sleep_usec) {
         left_to_record = check_left_to_record(u, n);
 
         if (u->use_tsched)
-            if (pa_bytes_to_usec(left_to_record, &u->source->sample_spec) > process_usec+max_sleep_usec/2)
+            if (!polled &&
+                pa_bytes_to_usec(left_to_record, &u->source->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= 0))
+        if (PA_UNLIKELY(n <= 0)) {
+
+            if (polled)
+                pa_log("ALSA woke us up to read new data from the device, but there was actually nothing to read! "
+                       "Most likely this is an ALSA driver bug. Please report this issue to the PulseAudio device.");
+
             break;
+        }
+
+        polled = FALSE;
 
         for (;;) {
             int err;
@@ -336,7 +345,7 @@ static int mmap_read(struct userdata *u, pa_usec_t *sleep_usec) {
     return work_done;
 }
 
-static int unix_read(struct userdata *u, pa_usec_t *sleep_usec) {
+static int unix_read(struct userdata *u, pa_usec_t *sleep_usec, pa_bool_t polled) {
     int work_done = 0;
     pa_usec_t max_sleep_usec = 0, process_usec = 0;
     size_t left_to_record;
@@ -364,11 +373,20 @@ static int unix_read(struct userdata *u, pa_usec_t *sleep_usec) {
         left_to_record = check_left_to_record(u, n);
 
         if (u->use_tsched)
-            if (pa_bytes_to_usec(left_to_record, &u->source->sample_spec) > process_usec+max_sleep_usec/2)
+            if (!polled &&
+                pa_bytes_to_usec(left_to_record, &u->source->sample_spec) > process_usec+max_sleep_usec/2)
                 break;
 
-        if (PA_UNLIKELY(n <= 0))
+        if (PA_UNLIKELY(n <= 0)) {
+
+            if (polled)
+                pa_log("ALSA woke us up to read new data from the device, but there was actually nothing to read! "
+                       "Most likely this is an ALSA driver bug. Please report this issue to the PulseAudio developers.");
+
             return work_done;
+        }
+
+        polled = FALSE;
 
         for (;;) {
             void *p;
@@ -950,6 +968,7 @@ static void source_update_requested_latency_cb(pa_source *s) {
 
 static void thread_func(void *userdata) {
     struct userdata *u = userdata;
+    unsigned short revents = 0;
 
     pa_assert(u);
 
@@ -972,9 +991,9 @@ static void thread_func(void *userdata) {
             pa_usec_t sleep_usec = 0;
 
             if (u->use_mmap)
-                work_done = mmap_read(u, &sleep_usec);
+                work_done = mmap_read(u, &sleep_usec, revents & POLLIN);
             else
-                work_done = unix_read(u, &sleep_usec);
+                work_done = unix_read(u, &sleep_usec, revents & POLLIN);
 
             if (work_done < 0)
                 goto fail;
@@ -1016,7 +1035,6 @@ static void thread_func(void *userdata) {
         /* Tell ALSA about this and process its response */
         if (PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
             struct pollfd *pollfd;
-            unsigned short revents = 0;
             int err;
             unsigned n;
 
@@ -1027,7 +1045,7 @@ static void thread_func(void *userdata) {
                 goto fail;
             }
 
-            if (revents & (POLLERR|POLLNVAL|POLLHUP|POLLPRI)) {
+            if (revents & (POLLOUT|POLLERR|POLLNVAL|POLLHUP|POLLPRI)) {
                 if (pa_alsa_recover_from_poll(u->pcm_handle, revents) < 0)
                     goto fail;
 
@@ -1036,7 +1054,8 @@ static void thread_func(void *userdata) {
 
             if (revents && u->use_tsched)
                 pa_log_debug("Wakeup from ALSA!%s%s", (revents & POLLIN) ? " INPUT" : "", (revents & POLLOUT) ? " OUTPUT" : "");
-        }
+        } else
+            revents = 0;
     }
 
 fail:
-- 
1.6.0.3

